<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-R9PJJHTM45"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-R9PJJHTM45");
    </script>

    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2255772939149085"
      crossorigin="anonymous"
    ></script>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="icon" href="/Img/orglogo.png" sizes="16x16 32x32" />

    <meta
      name="description"
      content="Explore a comprehensive collection of MAKAUT question papers covering all courses and semesters at MAKAUT University. Enhance your BCA journey with a range of MAKAUT BCA papers available for your reference. Elevate your exam preparation with our meticulously organized resources."
    />

    <meta
      name="keywords"
      content="MAKAUT Question Papers, All Courses, All Semester, MAKAUT University, BCA Papers"
    />
    <link rel="stylesheet" href="answer.css" />
    <link rel="stylesheet" href="/style.css" />
    <title>
      MAKAUT BCA DBMS Solution- All Courses, All Semesters | MAKAUT University
      BCA Papers with solution.
    </title>

    <link rel="stylesheet" href="/style.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM"
      crossorigin="anonymous"
    />
    <script
      src="https://kit.fontawesome.com/2a395c6dfb.js"
      crossorigin="anonymous"
    ></script>
  </head>

  <body style="background-color: #f8f8f8">
    <!-- Header Starts -->

    <nav
      class="navbar navbar-expand-lg bg-body-tertiary fixed-top mb-4 shadow-sm"
    >
      <div class="container-fluid d-">
        <a class="navbar-brand text-danger fw-bolder" href="/Index.html"
          >MAKAUT.org</a
        >
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item">
              <a
                class="nav-link active text-primary-emphasis fw-semibold"
                aria-current="page"
                href="/Index.html"
                >HOME</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active text-primary-emphasis fw-semibold"
                href="/Index.html"
                >QUESTION PAPER</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active text-primary-emphasis fw-semibold"
                href="/notice.html"
                >LATEST NEWS</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active text-primary-emphasis fw-semibold"
                aria-current="page"
                href="/contact.html"
                >CONTACT</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active text-primary-emphasis fw-semibold"
                aria-current="page"
                href="/about.html"
                >ABOUT US</a
              >
            </li>
            <li class="nav-item">
              <a
                class="nav-link active text-primary-emphasis fw-semibold"
                aria-current="page"
                href="/Privacy.html"
                >PRIVACY POLICY</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <!-- Header ends -->

    <div
      class="container"
      style="
        max-width: 850px;
        margin: auto;
        font-family: poppins;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
      "
    >
      <div class="shadow-sm p-3 mb-5 bg-white rounded">
        <h1 id="articleTitle">
          MAKAUT BCA DBMS Previous Year Questions (PYQ) with Solutions
        </h1>

        <h2 id="articlesubTitle">
          This page provides a comprehensive collection of previous year
          questions (PYQ) from MAKAUT's BCA Data Structures and Algorithm (DBMS)
          exams. Many questions are frequently repeated, making this resource
          essential for exam preparation. It includes key theory questions with
          detailed answers that can be easily memorized or conceptually
          understood. Whether you're revising for upcoming exams or looking for
          solved papers, this resource is designed to help you excel in your DBMS
          subject.
        </h2>
        <a
          id="articlesubTitle"
          href="https://docs.google.com/document/d/1KIMpaH0SPegciaofXMTZ9Z-RJ4DpQmxELLrauYHuh3Y/edit?usp=sharing"
          >View the answers in google docs.
        </a>

        <h1>
          Makaut PYQs Database and Management System Solved Questions by
          MAKAUT.org:
        </h1>
        <p>
          For any special request contact us at
          <a href="https://makaut.org/contact">makaut.org/contact</a>.
        </p>
        <p></p>
        <h3>Q1. Define super key, candidate key and primary key?</h3>
        <p></p>
        <p>
          Ans: Super Key, Candidate Key, and Primary Key are important concepts
          in database management systems (DBMS).
        </p>
        <ol start="1">
          <li>
            Super Key: A super key is a set of one or more attributes (columns)
            that can uniquely identify a record in a table. It can have
            additional attributes that are not necessary for unique
            identification. Example: In a student table, if you have Roll_No,
            Name, and Phone_Number, then {Roll_No}, {Roll_No, Name}, and
            {Roll_No, Phone_Number} are all super keys.
          </li>
          <li>
            Candidate Key: A candidate key is a minimal super key, meaning it
            has no unnecessary attributes. It is the smallest possible
            combination of attributes that can still uniquely identify a record.
            Example: If {Roll_No} is enough to uniquely identify a student, it
            is a candidate key. {Roll_No, Name} is a super key but not a
            candidate key because Name is unnecessary.
          </li>
          <li>
            Primary Key: A primary key is a candidate key that is chosen by the
            database designer as the main key to uniquely identify records in a
            table. It cannot have NULL values and must be unique. Example: If
            Roll_No is chosen as the primary key, it will uniquely identify
            every student in the table.
          </li>
        </ol>
        <p></p>
        <h3>Q2. Define 3 schema architecture in DBMS?</h3>
        <p></p>
        <p>
          Ans: The three-schema architecture is a framework in DBMS that helps
          in abstracting and managing data effectively by dividing it into three
          levels: internal, conceptual, and external.
        </p>
        <ol start="1">
          <li>
            Internal Schema (Physical Level):<br />The internal schema is the
            lowest level that describes the physical storage of data. It focuses
            on how data is stored, organized, and accessed in memory,
            considering storage efficiency and optimization techniques like
            indexing and file management.
          </li>
          <li>
            Conceptual Schema (Logical Level):<br />The conceptual schema
            represents the entire database's logical view. It defines what data
            is stored and how different data elements are related to each other,
            such as tables, attributes, and relationships. This level hides the
            complexities of the physical storage and provides a unified view of
            the data structure.
          </li>
          <li>
            External Schema (View Level):<br />The external schema defines
            various user-specific views of the database. Different users can
            have customized views based on their requirements. This level
            provides tailored access to the database by hiding certain data or
            presenting only relevant information to specific users.
          </li>
        </ol>
        <p>
          Each schema level ensures data abstraction and separation, which
          simplifies the management of complex database systems.
        </p>
        <p></p>
        <h3>Q3.Explain 2 phase locking protocol?</h3>
        <p></p>
        <p>
          Ans: The two-phase locking (2PL) protocol is a method in DBMS that
          helps control the order of transactions to avoid problems like data
          conflicts and ensure that transactions happen in a consistent way. It
          works in two phases: growing and shrinking.
        </p>
        <ol start="1">
          <li>
            Growing Phase:<br />In this phase, the transaction can keep on
            acquiring (getting) locks on the data it needs. A lock is a way of
            securing data so that no other transaction can change it at the same
            time. During this growing phase, the transaction can get more locks
            as needed, but it cannot release (give up) any locks.
          </li>
          <li>
            Shrinking Phase:<br />Once the transaction has acquired all the
            locks it needs, it enters the shrinking phase. In this phase, it
            starts releasing the locks it holds. After entering this phase, the
            transaction cannot get any new locks; it can only release the locks
            it already has.
          </li>
        </ol>
        <p>
          By following this two-phase process, the protocol ensures that
          transactions happen one after another without causing confusion or
          errors. This makes the database operations more reliable and
          consistent.
        </p>
        <p></p>
        <h3>Q4.What is NULL? What is its importance?</h3>
        <p></p>
        <p>
          Ans: In DBMS, NULL represents a value that is missing, unknown, or not
          applicable. It is different from zero or an empty string; NULL means
          no data is stored in that field.
        </p>
        <p>Importance of NULL:</p>
        <ol start="1">
          <li>
            Represents Missing Data:<br />NULL is useful when data is not
            available or not provided. For example, in a student database, if a
            student’s phone number is unknown, NULL can be used instead of
            leaving it blank.
          </li>
          <li>
            Indicates Inapplicable Values:<br />Sometimes, a field may not apply
            to all records. For instance, in an employee database, some
            employees might not have a middle name. NULL can represent such
            cases.
          </li>
          <li>
            Maintains Data Integrity:<br />NULL helps in maintaining consistency
            in databases by providing a standard way to represent missing or
            irrelevant data, ensuring data integrity and accuracy.
          </li>
          <li>
            Supports Conditional Queries:<br />In SQL queries, conditions
            involving NULL are handled separately using IS NULL or IS NOT NULL,
            helping in filtering and analysing incomplete data effectively.
          </li>
        </ol>
        <p></p>
        <h3>
          Q5.How to represent a weak entity set in an ER diagram? Quote simple
          suitable example?
        </h3>
        <p></p>
        <p>
          Ans: In an ER (Entity-Relationship) diagram, a weak entity set is
          represented by:
        </p>
        <ol start="1">
          <li>
            Double Rectangles: The weak entity itself is represented by a
            rectangle with double lines.
          </li>
          <li>
            Double Diamonds: The relationship between the weak entity and its
            identifying strong entity is represented by a diamond with double
            lines.
          </li>
          <li>
            Partial Key (Dashed Underline): The weak entity’s attribute that
            partially identifies it is underlined using a dashed line.
          </li>
        </ol>
        <p>
          Simple Example:<br />Consider a scenario where “Dependents” (like
          spouse or children) are linked to an “Employee”. The Dependents cannot
          be uniquely identified without knowing which Employee they belong to.
        </p>
        <p>In the ER diagram:</p>
        <ul>
          <li>
            Employees (strong entity) is represented by a single rectangle.
          </li>
          <li>
            Dependents (weak entity) is represented by a double rectangle.
          </li>
          <li>
            The relationship Has between Employee and Dependents is represented
            by a double diamond.
          </li>
          <li>
            Dependent_Name (partial key) is underlined with a dashed line to
            show it cannot uniquely identify a dependent without the Employee
            reference.
          </li>
        </ul>
        <p>
          This setup visually distinguishes a weak entity set in an ER diagram
          while showing its dependency on a strong entity.
        </p>
        <p></p>
        <h3>Q6.Draw a diagram for traditional “library management system” ?</h3>
        <p></p>
        <p>Ans:</p>
        <p>
          <img
            alt=""
            src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXfD-F-hHPJjM8kkPO50IzgGMs9qJYtW2uP9yHMNSDXHyRLNaGKJmLVScqIL0dInQQMLOqXvwBJRFj-lXVA-TfJwjJbdLYQisFtGRBNPxYQW_UBu1Bb9O0zdrNiY9hFzgMRnVNAxK_OER3wRUtSi6w?key=Mt2cBuuHeVFsMQHizIfKLg"
            title=""
          />
        </p>
        <p>
          Here is the ER diagram for a Library Management System that includes
          key entities like Library, Books, Members, Staff, and Transactions.
          The relationships and attributes are clearly represented to illustrate
          how they interact in the system.
        </p>
        <p></p>
        <h3>
          Q7.Consider the following schema :Employee_Salary (EmpNo, EName, Dept,
          DOB, Salary)
        </h3>
        <h3>Write SQL to perform the following:</h3>
        <ol start="1">
          <li>
            <h3>Display the number of employees in each department.</h3>
          </li>
          <li>
            <h3>
              Display the total and average salaries of employees in "Computer
              Science" department. -Display the sum of salaries for all
              departments.
            </h3>
          </li>
          <li>
            <h3>
              Display the highest and lowest salary for "Computer Science"
              department.
            </h3>
          </li>
          <li>
            <h3>
              Display the names of those employees whose name starts with "A".
            </h3>
          </li>
        </ol>
        <p></p>
        <p>Ans: SQL Queries for Employee_Salary Schema</p>
        <p>Given Schema: Employee_Salary (EmpNo, EName, Dept, DOB, Salary)</p>
        <p></p>
        <p>1. Display the number of employees in each department:</p>
        <p></p>
        <p>sql</p>
        <p>SELECT Dept, COUNT(*) AS Number_of_Employees</p>
        <p>FROM Employee_Salary</p>
        <p>GROUP BY Dept;</p>
        <p>
          2. Display the total and average salaries of employees in the
          "Computer Science" department:
        </p>
        <p></p>
        <p>sql</p>
        <p>SELECT SUM(Salary) AS Total_Salary, AVG(Salary) AS Average_Salary</p>
        <p>FROM Employee_Salary</p>
        <p>WHERE Dept = 'Computer Science';</p>
        <p>3. Display the sum of salaries for all departments:</p>
        <p></p>
        <p>sql</p>
        <p>SELECT Dept, SUM(Salary) AS Total_Salary</p>
        <p>FROM Employee_Salary</p>
        <p>GROUP BY Dept;</p>
        <p>
          4. Display the highest and lowest salary for the "Computer Science"
          department:
        </p>
        <p></p>
        <p>sql</p>
        <p>
          SELECT MAX(Salary) AS Highest_Salary, MIN(Salary) AS Lowest_Salary
        </p>
        <p>FROM Employee_Salary</p>
        <p>WHERE Dept = 'Computer Science';</p>
        <p>
          5. Display the names of those employees whose name starts with "A":
        </p>
        <p></p>
        <p>sql</p>
        <p>SELECT EName</p>
        <p>FROM Employee_Salary</p>
        <p>WHERE EName LIKE 'A%';</p>
        <p></p>
        <h3>Q8.Define 2NF and 3NF?</h3>
        <p></p>
        <p>
          Ans: A table is said to be in Second Normal Form (2NF) if it meets the
          criteria for First Normal Form (1NF) and, in addition, every non-key
          attribute is fully functionally dependent on the entire primary key.
          This means that if the primary key is a composite key (made up of more
          than one column), then all the attributes in the table must depend on
          all parts of this composite key, not just some of them.
        </p>
        <p>
          For example: Consider a table with the primary key consisting of
          StudentID and CourseID. If there is an attribute like Grade, it should
          depend on both StudentID and CourseID together. If Grade depended only
          on StudentID, then the table would not be in 2NF.
        </p>
        <p>3NF (Third Normal Form):</p>
        <p>
          A table is in Third Normal Form (3NF) if it is in Second Normal Form
          (2NF) and, in addition, there are no transitive dependencies. This
          means that non-key attributes should not depend on other non-key
          attributes. In simpler terms, every non-key attribute must be directly
          dependent on the primary key and not on other non-key attributes.
        </p>
        <p>
          For example: In a table where StudentID is the primary key, if there
          is a non-key attribute like DepartmentName which depends on another
          non-key attribute DepartmentID, then the table is not in 3NF. Instead,
          DepartmentName should directly depend on StudentID or be moved to a
          separate table.
        </p>
        <h3>Q9.Write a short note on file indexing?</h3>
        <p></p>
        <p>
          Ans: File indexing is a technique used in databases to speed up data
          retrieval by creating a data structure that allows for quick access to
          records. Instead of scanning through the entire file, the database can
          use the index to find data more efficiently.
        </p>
        <p>
          Purpose: The main purpose of indexing is to make data retrieval
          faster. An index provides a faster way to locate data by creating a
          sorted list of keys and their corresponding pointers to the actual
          data.
        </p>
        <p>
          Structure: An index typically uses a hierarchical or tree-like
          structure, such as a B-tree or hash table. This structure helps in
          quickly finding the data without scanning the whole file.
        </p>
        <p>Types of Indexes:</p>
        <ul>
          <li>
            Primary Index: This index is created on the primary key of a table,
            allowing for quick retrieval of records based on this unique
            identifier.
          </li>
          <li>
            Secondary Index: This index is created on columns other than the
            primary key. It improves performance for queries that involve these
            columns.
          </li>
          <li>
            Clustered Index: This type of index arranges the data in the file
            according to the index. The data is physically ordered based on the
            index. A file can have only one clustered index.
          </li>
          <li>
            Non-Clustered Index: This index is separate from the data and
            contains pointers to the data location. It allows multiple
            non-clustered indexes on a file.
          </li>
        </ul>
        <p>
          Benefits: Indexing enhances the speed of data retrieval and improves
          performance for searching, sorting, and filtering operations.
        </p>
        <p>
          Trade-offs: While indexing speeds up read operations, it requires
          additional storage space and can slow down write operations, such as
          inserts, updates, and deletes, because the index needs to be updated.
        </p>
        <p></p>
        <h3>Q10.Write a short note on query optimization technique?</h3>
        <p>
          Query optimization is a critical process in database management
          systems (DBMS) aimed at improving the performance of SQL queries. The
          objective is to execute queries in the most efficient manner possible,
          minimizing resource usage and reducing the time required to retrieve
          data.
        </p>
        <p>Techniques:</p>
        <ol start="1">
          <li>
            Indexing: Creating indexes on columns that are frequently used in
            search conditions or joins can significantly speed up query
            performance. Indexes provide a faster way to access data by allowing
            the database to locate the required information quickly.
          </li>
          <li>
            Query Restructuring: Sometimes, rewriting a query can improve its
            performance. This may involve simplifying complex queries, using
            subqueries effectively, or eliminating unnecessary calculations to
            make the query more efficient.
          </li>
          <li>
            Execution Plan Analysis: The DBMS generates an execution plan for
            each query, which outlines how the data will be retrieved. Analyzing
            this plan helps in identifying any performance issues and selecting
            the best strategy for executing the query.
          </li>
          <li>
            Database Statistics: Keeping accurate and up-to-date database
            statistics is essential for the query optimizer. These statistics
            help the optimizer make informed decisions about the most efficient
            way to execute a query.
          </li>
          <li>
            Join Optimization: When a query involves multiple tables, choosing
            the appropriate join method (e.g., nested loop, hash join, or merge
            join) and ordering the joins efficiently can improve query
            performance.
          </li>
        </ol>
        <p></p>
        <h3>Q11.Write a short note on Armstrong's axioms?</h3>
        <p>
          Ans: Armstrong's axioms are a set of rules used in databases to help
          understand and work with functional dependencies. These rules are
          essential for organizing and normalizing databases to make them more
          efficient and reduce redundancy.
        </p>
        <p>Here are the three basic axioms:</p>
        <ol start="1">
          <li>
            Reflexivity: If a set of attributes YYY is part of another set XXX,
            then XXX can determine YYY. For example, if you have a set of
            attributes {StudentID, Course}, then {StudentID} can determine
            {StudentID}, {Course}, or both because {StudentID} is part of the
            set.
          </li>
          <li>
            Augmentation: If XXX determines YYY, then adding extra attributes to
            both XXX and YYY will still hold true. For example, if {StudentID}
            determines {Name}, then {StudentID, Course} will determine {Name,
            Course}. Adding more attributes to both sides of the dependency
            doesn’t change the fact that XXX still determines YYY.
          </li>
          <li>
            Transitivity: If XXX determines YYY and YYY determines ZZZ, then XXX
            will also determine ZZZ. For example, if {StudentID} determines
            {Course} and {Course} determines {Instructor}, then {StudentID} will
            determine {Instructor} through {Course}.
          </li>
        </ol>
        <h3>Q12.Write a short note on Network data model?</h3>
        <p>
          Ans: The Network Data Model is a database model that represents data
          as a network of interconnected records. This model allows for more
          complex relationships between data elements compared to the
          hierarchical model, supporting many-to-many relationships and
          providing greater flexibility in data management.
        </p>
        <p>Key Features:</p>
        <ul>
          <li>
            Structure: In the Network Data Model, data is organised into records
            (nodes) that are connected by links (edges). Each record can have
            multiple parent and child records, forming a graph-like structure.
            This setup supports many-to-many relationships between records,
            unlike the hierarchical model, which only supports one-to-many
            relationships.
          </li>
          <li>
            Data Relationships: Records are connected in a network, allowing for
            flexible and dynamic relationships. Each record can be linked to
            multiple other records, creating a complex web of relationships.
            This is useful for representing real-world scenarios where entities
            have multiple relationships.
          </li>
          <li>
            Schema: The schema of a network database is represented as a network
            diagram. It shows records and their relationships, often depicted as
            nodes and links. This visual representation helps in understanding
            how different pieces of data are related.
          </li>
          <li>
            Data Access: Data retrieval in the Network Data Model typically
            involves navigating through the network of records using pointers.
            This method can be efficient for certain types of queries but may
            require more complex navigation compared to other models.
          </li>
          <li>
            Examples: One common example of a network database is a
            telecommunications database where various entities like customers,
            services, and billing records are interconnected. Another example is
            a transportation network where locations, routes, and schedules are
            linked in a network.
          </li>
        </ul>
        <p>Advantages:</p>
        <ul>
          <li>
            Flexibility: The Network Data Model supports complex many-to-many
            relationships, providing more flexibility in data representation
            compared to simpler hierarchical models.
          </li>
          <li>
            Efficiency: It can be efficient for certain types of queries that
            require traversing multiple relationships, especially when the
            relationships are complex.
          </li>
        </ul>
        <p>Disadvantages:</p>
        <ul>
          <li>
            Complexity: The network of records can become complex and difficult
            to manage, especially as the number of relationships increases.
          </li>
          <li>
            Navigational Complexity: Accessing data requires navigating through
            pointers, which can be complex and less intuitive compared to other
            models like the relational model.
          </li>
        </ul>
        <p></p>
        <h3>
          Q13.What is Fragmentation ? How many types are there ? Briefly explain
          each of them with suitable examples.
        </h3>
        <p>
          Ans: In a database, fragmentation means breaking a large table into
          smaller pieces. These smaller parts are easier to manage and store
          across different locations. The goal is to improve performance,
          availability, and efficiency.
        </p>
        <p>Types of Fragmentation:</p>
        <p>There are three main types of fragmentation:</p>
        <ol start="1">
          <li>Horizontal Fragmentation:</li>
        </ol>
        <ul>
          <li>
            Here, the table is divided row-wise. We split the data based on
            certain conditions, so different sets of rows are stored separately.
          </li>
          <li>
            Example: Consider a student table. We can horizontally fragment it
            based on the department:
          </li>
        </ul>
        <ul>
          <li>Fragment 1: Contains students from the CSE department.</li>
          <li>Fragment 2: Contains students from the ECE department.</li>
        </ul>
        <ol start="2">
          <li>Vertical Fragmentation:</li>
        </ol>
        <ul>
          <li>
            In vertical fragmentation, the table is split column-wise. Different
            sets of columns are stored in separate fragments.
          </li>
          <li>
            Example: Consider a student table with columns: Student_ID, Name,
            Address, Marks.
          </li>
        </ul>
        <ul>
          <li>Fragment 1: Contains Student_ID and Name.</li>
          <li>Fragment 2: Contains Address and Marks.</li>
        </ul>
        <ol start="3">
          <li>Mixed (Hybrid) Fragmentation:</li>
        </ol>
        <ul>
          <li>
            This is a combination of both horizontal and vertical fragmentation.
            The table is first split row-wise (horizontal) and then column-wise
            (vertical).
          </li>
          <li>
            Example: First, we divide the student table based on departments
            (horizontal). Then, in each department, we further split data into
            different columns (vertical).
          </li>
        </ul>
        <p>
          This method of breaking down large databases helps in better query
          performance and resource management.
        </p>
        <p></p>
        <h3>Q14.Explain the basic principle of time stamp protocol.</h3>
        <p>Ans: Basic Principle of Timestamp Protocol:</p>
        <p>
          The Timestamp Protocol is used in DBMS to control concurrency. It
          ensures that transactions are executed in a safe order, preventing
          conflicts.
        </p>
        <p>How it Works:</p>
        <p>
          Each transaction is given a unique timestamp when it starts. The
          timestamp reflects when the transaction began. For each data item,
          there are two timestamps:
        </p>
        <ul>
          <li>
            Read Timestamp (RTS): This records the last time the item was read.
          </li>
          <li>
            Write Timestamp (WTS): This records the last time the item was
            written.
          </li>
        </ul>
        <p>
          The protocol uses these timestamps to order transactions. Transactions
          with smaller timestamps (older transactions) are given priority over
          those with larger timestamps (newer transactions).
        </p>
        <p>Rules for Reading and Writing:</p>
        <p>
          For a read operation, a transaction is allowed to read a data item
          only if its write timestamp is older than the transaction’s timestamp.
          If the transaction is newer than the last write, it can proceed.
        </p>
        <p>
          For a write operation, a transaction can write to a data item if both
          the read and write timestamps of that item are older than the
          transaction’s timestamp. This ensures no newer transaction has
          accessed or modified the data.
        </p>
        <p>Example:</p>
        <p>
          If Transaction T1 has a timestamp of 10 and Transaction T2 has a
          timestamp of 15, T1 will be prioritized. If T2 tries to write to a
          data item that T1 has already accessed, T2 may be rolled back to
          prevent inconsistency.
        </p>
        <p></p>
        <h3>Q15.Write a short note on Network data model?</h3>
        <p>
          Ans: In a database system, deadlock happens when two or more
          transactions block each other indefinitely. Each transaction is
          waiting for a resource that is held by another transaction, and no one
          can proceed.
        </p>
        <p>Causes of Deadlock in a Database System:</p>
        <ol start="1">
          <li>
            Mutual Exclusion:<br />In a database, resources like data items are
            held in an exclusive manner by one transaction at a time. If
            Transaction A locks a resource, Transaction B cannot access it until
            A releases it. If both transactions are holding resources and
            waiting for each other’s resources, a deadlock can occur.
          </li>
          <li>
            Hold and Wait:<br />This happens when a transaction is holding some
            resources while waiting for others. For example, Transaction A holds
            Resource 1 and is waiting for Resource 2, while Transaction B holds
            Resource 2 and is waiting for Resource 1. Neither can proceed,
            leading to a deadlock.
          </li>
          <li>
            No Preemption:<br />Resources in a database are not forcibly taken
            away from a transaction. Once a transaction holds a resource, it
            cannot be preempted by another transaction. If a transaction does
            not release a resource voluntarily, deadlock can occur.
          </li>
          <li>
            Circular Wait:<br />In a deadlock situation, a circular chain of
            transactions is formed. For instance, Transaction A is waiting for a
            resource held by Transaction B, B is waiting for a resource held by
            Transaction C, and C is waiting for a resource held by Transaction
            A. This circular waiting leads to deadlock.
          </li>
        </ol>
        <p></p>
        <h3>
          Q16.Discuss the relative advantages and disadvantages of a distributed
          database.
        </h3>
        <p>Ans: Advantages of a Distributed Database:</p>
        <ol start="1">
          <li>
            Improved Reliability and Availability:<br />In a distributed
            database, data is stored across multiple locations. If one site
            fails, the system can still function using data from other sites.
            This improves the reliability and availability of the database.
          </li>
          <li>
            Scalability:<br />Distributed databases can easily scale by adding
            more nodes or sites. This allows the system to handle increased
            loads and larger datasets without performance degradation.
          </li>
          <li>
            Local Control:<br />Each site in a distributed database can manage
            its data independently. This allows for better control and
            customization to meet the specific needs of local users, reducing
            the dependency on a central site.
          </li>
          <li>
            Faster Data Access:<br />Since data is distributed across multiple
            sites, users can access data from the nearest location. This reduces
            the time needed to retrieve data, improving overall performance.
          </li>
          <li>
            Flexibility:<br />A distributed database can be designed to meet the
            specific needs of different locations. For example, certain data can
            be stored locally for faster access while other data is shared
            globally.
          </li>
        </ol>
        <p>Disadvantages of a Distributed Database:</p>
        <ol start="1">
          <li>
            Complexity:<br />Managing a distributed database is more complex
            compared to a centralized one. It involves challenges like data
            synchronization, consistency, and dealing with network issues.
          </li>
          <li>
            Higher Costs:<br />Setting up and maintaining a distributed database
            is usually more expensive. It requires additional hardware,
            software, and skilled personnel to manage the system effectively.
          </li>
          <li>
            Data Security:<br />In a distributed system, data is spread across
            multiple sites, which can increase the risk of security breaches.
            Ensuring data security in such a system requires robust security
            measures.
          </li>
          <li>
            Data Integrity:<br />Maintaining data integrity and consistency
            across multiple sites is challenging. There’s a risk of data
            conflicts, especially when multiple users update the same data
            simultaneously.
          </li>
          <li>
            Network Dependency:<br />Distributed databases rely heavily on
            network communication. If the network fails or becomes slow, it can
            affect the performance and availability of the entire system.
          </li>
        </ol>
        <p></p>
        <h3>Q17.Explain cascading rollback with an example.</h3>
        <p>
          Ans: Cascading rollback happens when the failure of one transaction
          causes other dependent transactions to fail and roll back as well.
          This occurs because transactions rely on each other's changes, so if
          one fails, the others may become invalid.
        </p>
        <p>Example of Cascading Rollback:</p>
        <ol start="1">
          <li>Transaction T1: Updates a student’s marks.</li>
          <li>
            Transaction T2: Reads the updated marks from T1 and uses them to
            calculate the student’s grade.
          </li>
          <li>
            Transaction T3: Reads the grade calculated by T2 and updates the
            report card.
          </li>
        </ol>
        <p>In this situation:</p>
        <ul>
          <li>If T1 fails and rolls back, the updated marks are undone.</li>
          <li>
            Since T2 used these marks to calculate the grade, it also becomes
            invalid and must roll back.
          </li>
          <li>
            T3, which depends on the grade from T2, also needs to roll back.
          </li>
        </ul>
        <p>
          This chain reaction, where the failure of T1 affects T2 and T3, is
          called cascading rollback.
        </p>
        <p></p>
        <h3>Q18.What is Transaction ? What is interleaving in Transaction ?</h3>
        <p>
          Ans: A transaction in DBMS is a sequence of operations performed as a
          single logical unit of work. These operations could involve reading,
          writing, updating, or deleting data in a database. A transaction must
          satisfy four key properties, known as ACID properties:
        </p>
        <ul>
          <li>
            Atomicity: All operations must be completed; if not, none are
            applied.
          </li>
          <li>
            Consistency: The database remains consistent before and after the
            transaction.
          </li>
          <li>Isolation: Transactions run independently of each other.</li>
          <li>
            Durability: Once a transaction is committed, the changes are
            permanent.
          </li>
        </ul>
        <p>
          Interleaving refers to the process of executing multiple transactions
          in a way where their operations are mixed or overlapped. This is done
          to maximize system efficiency and allow concurrent transactions.
        </p>
        <p>
          For example, if two transactions, T1 and T2, are being executed, their
          operations may be interleaved like this:
        </p>
        <ul>
          <li>Step 1: Execute part of T1.</li>
          <li>Step 2: Execute part of T2.</li>
          <li>Step 3: Continue executing T1.</li>
          <li>Step 4: Continue executing T2.</li>
        </ul>
        <p>
          Interleaving is common in multi-user environments where multiple
          transactions are handled simultaneously. The goal is to improve
          performance while ensuring that the outcome is as if the transactions
          were executed sequentially.
        </p>
        <p></p>
        <h3>Q19.Describe the properties of Transaction.</h3>
        <p>Ans: Properties of Transaction (ACID Properties):</p>
        <p>
          In DBMS, transactions must satisfy four essential properties known as
          ACID properties. These properties ensure that transactions are
          processed reliably and maintain the integrity of the database.
        </p>
        <ol start="1">
          <li>
            Atomicity:<br />Atomicity means that a transaction is treated as a
            single unit. Either all operations in the transaction are completed
            successfully, or none are applied. If any operation fails, the
            entire transaction is rolled back, ensuring that no partial changes
            are made to the database.<br />Example: If a bank transaction
            involves transferring money from Account A to Account B, either both
            debit and credit operations happen, or neither happens.
          </li>
          <li>
            Consistency:<br />Consistency ensures that a transaction brings the
            database from one valid state to another. The integrity of the data
            is maintained before and after the transaction. Even if a
            transaction fails, the database remains consistent.<br />Example: In
            the same bank transaction, if money is deducted from Account A, it
            must be added to Account B. The total balance across accounts
            remains consistent.
          </li>
          <li>
            Isolation:<br />Isolation ensures that transactions are executed
            independently, without interference from other transactions. Even
            when transactions run concurrently, the outcome should be the same
            as if they were executed one after the other.<br />Example: If two
            customers are withdrawing money from the same account at the same
            time, each transaction should be processed without affecting the
            other.
          </li>
          <li>
            Durability:<br />Durability guarantees that once a transaction is
            committed, the changes are permanent, even in case of a system
            failure. The committed data is saved in non-volatile storage,
            ensuring it is not lost.<br />Example: After transferring money
            between accounts, even if the system crashes, the updated balances
            are saved and remain intact.
          </li>
        </ol>
        <p></p>
        <h3>Q20.Explain 5th normal form with example.</h3>
        <p>
          Ans: The 5th Normal Form (5NF), also known as Project-Join Normal Form
          (PJNF), is a level of database normalization used to ensure that a
          database is free from redundancy and anomalies due to multiple
          relationships among data.
        </p>
        <p>Definition:</p>
        <p>
          A table is in 5NF if it is in 4NF (Fourth Normal Form) and all its
          join dependencies are implied by the candidate keys. This means that
          every table should be decomposed into smaller tables to ensure that
          the original data can be reconstructed using joins without redundancy
          or loss of information.
        </p>
        <p>Key Points:</p>
        <ul>
          <li>
            Join Dependency: A table is in 5NF if it is not possible to
            decompose the table into smaller tables without losing information.
            All join dependencies should be a consequence of the candidate keys.
          </li>
          <li>
            Lossless Decomposition: Decomposition should be lossless, meaning
            that you can reconstruct the original table by joining the
            decomposed tables.
          </li>
        </ul>
        <p>Example:</p>
        <p>
          Consider a table that tracks student course enrollments and their
          instructors:
        </p>
        <table>
          <tbody>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Student</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Course</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Instructor</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Alice</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Math</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Smith</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Alice</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Science</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Jones</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Bob</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Math</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Smith</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Bob</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>History</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Brown</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>In this table:</p>
        <ul>
          <li>A student can enroll in multiple courses.</li>
          <li>A course can have multiple instructors.</li>
          <li>An instructor can teach multiple courses.</li>
        </ul>
        <p>Decomposition into 5NF:</p>
        <p>
          To decompose this table into 5NF, we need to ensure that no
          information is lost and the data can be reconstructed by joining the
          decomposed tables.
        </p>
        <ol start="1">
          <li>First Decomposition:</li>
        </ol>
        <p>Student-Course Table:</p>
        <table>
          <tbody>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Student</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Course</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Alice</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Math</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Alice</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Science</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Bob</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Math</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Bob</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>History</p>
              </td>
            </tr>
          </tbody>
        </table>
        <ul>
          <li>Course-Instructor Table:</li>
        </ul>
        <table>
          <tbody>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Course</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Instructor</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Math</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Smith</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Science</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Jones</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>History</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Brown</p>
              </td>
            </tr>
          </tbody>
        </table>
        <ol start="2">
          <li>Second Decomposition:</li>
        </ol>
        <p>Student-Instructor Table:</p>
        <table>
          <tbody>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Student</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Instructor</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Alice</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Smith</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Alice</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Jones</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Bob</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Smith</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Bob</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dr. Brown</p>
              </td>
            </tr>
          </tbody>
        </table>
        <p>Each of the decomposed tables satisfies 5NF as follows:</p>
        <ul>
          <li>
            Student-Course Table: Each combination of student and course is
            unique.
          </li>
          <li>
            Course-Instructor Table: Each course has a list of instructors.
          </li>
          <li>
            Student-Instructor Table: Each student is associated with their
            instructors.
          </li>
        </ul>
        <h3>Q20.Explain 5th normal form with example.</h3>
        <p>
          Ans: Embedded SQL refers to integrating SQL commands within a host
          programming language such as C, Java, or COBOL. This approach allows
          the application to execute SQL queries and interact with a database
          directly from the code.
        </p>
        <p>Application Example:</p>
        <p>
          Consider a banking application where embedded SQL is used to manage
          various tasks like retrieving account details, updating balances, or
          inserting new transactions. The application code includes SQL commands
          to perform these operations, making it easier to handle database
          interactions within the application logic.
        </p>
        <p>Static vs. Dynamic Embedded SQL:</p>
        <ul>
          <li>Static Embedded SQL:</li>
        </ul>
        <ul>
          <li>
            Definition: SQL queries are predefined and fixed within the code,
            and these queries are known at compile time.
          </li>
          <li>
            Advantages: Easier to debug and optimize because the SQL statements
            are fixed and do not change.
          </li>
          <li>
            Disadvantages: Less flexible, as any change to the query requires
            modifying and recompiling the code.
          </li>
        </ul>
        <ul>
          <li>Dynamic Embedded SQL:</li>
        </ul>
        <ul>
          <li>
            Definition: SQL queries are constructed and executed at runtime,
            based on user input or other conditions.
          </li>
          <li>
            Advantages: Offers greater flexibility, allowing the application to
            adapt queries according to different runtime scenarios or user
            inputs.
          </li>
          <li>
            Disadvantages: More complex to implement and can pose security risks
            like SQL injection if not managed properly.
          </li>
        </ul>
        <p></p>
        <p></p>
        <h3>Q21.Differentiate between 3NF and BCNF.</h3>
        <p>Ans:</p>
        <table>
          <tbody>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Aspect</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Third Normal Form (3NF)</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Boyce-Codd Normal Form (BCNF)</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Definition</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  A table is in 3NF if it is in 2NF and all non-key attributes
                  are non-transitively dependent on the primary key.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  A table is in BCNF if it is in 3NF and for every non-trivial
                  functional dependency, the left-hand side is a superkey.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Focus</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Removes transitive dependencies, where non-key attributes
                  depend on other non-key attributes.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Ensures that every functional dependency is enforced by a
                  superkey, which can handle more complex dependency scenarios.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Requirement</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  3NF deals with non-key attributes and ensures they depend only
                  on the primary key.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  BCNF handles all functional dependencies, including those
                  where a non-superkey attribute determines another attribute.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Example</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  In a table with attributes (StudentID, Course, Instructor),
                  where Instructor depends on Course, but not on StudentID, it
                  must be in 3NF.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  If a table with attributes (Course, Instructor, Room) has
                  dependencies like Course → Instructor and Instructor → Room,
                  it might not be in BCNF if Instructor is not a superkey.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Handling Dependencies</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Handles transitive dependencies by ensuring non-key attributes
                  do not depend on other non-key attributes.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Handles all functional dependencies by ensuring every
                  determinant is a superkey.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Normalization Goal</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Aims to eliminate transitive dependency and improve data
                  integrity.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Aims to eliminate redundancy related to functional
                  dependencies by enforcing more rigorous constraints.
                </p>
              </td>
            </tr>
          </tbody>
        </table>
        <p></p>
        <h3>Q22.What is View Serializability ?</h3>
        <p>
          Ans: A schedule is view serializable if it can be transformed into a
          serial schedule by reordering transactions, while preserving the final
          state of the database. This means the outcome of the concurrent
          execution matches the result of some serial execution.
        </p>
        <p>Example:</p>
        <p>Suppose we have two transactions:</p>
        <ul>
          <li>Transaction T1: Reads and writes data item A.</li>
          <li>Transaction T2: Reads and writes data item B.</li>
        </ul>
        <p>
          In one schedule, T1 might complete all its operations before T2
          starts. In another schedule, T1 and T2’s operations might be
          interleaved. If the final result of the interleaved schedule is the
          same as if T1 and T2 had run serially, the schedule is view
          serializable.
        </p>
        <p></p>
        <h3>Q23.Explain non-recoverable schedule with an example.</h3>
        <p>
          Ans:A non-recoverable schedule is a sequence of transactions where, if
          a transaction that has modified the database is rolled back, the
          database cannot be returned to a consistent state without affecting
          other transactions that have already committed. This means that the
          effects of a committed transaction might depend on the results of
          uncommitted transactions, leading to inconsistencies if those
          uncommitted transactions are later rolled back.
        </p>
        <p>Example:</p>
        <p>
          Consider two transactions, T1 and T2, with the following operations:
        </p>
        <ul>
          <li>Transaction T1:</li>
        </ul>
        <ol start="1">
          <li>Read(A)</li>
          <li>Write(A)</li>
        </ol>
        <ul>
          <li>Transaction T2:</li>
        </ul>
        <ol start="1">
          <li>Read(A)</li>
          <li>Write(A)</li>
        </ol>
        <p>Assume the following sequence of operations:</p>
        <ol start="1">
          <li>T1 reads value A.</li>
          <li>
            T2 reads value A (which is the same value T1 read before T1 writes
            to A).
          </li>
          <li>T1 writes a new value to A.</li>
          <li>T2 writes a new value to A.</li>
          <li>T1 commits.</li>
          <li>T2 rolls back.</li>
        </ol>
        <p>In this scenario:</p>
        <ul>
          <li>T1 has committed, making its changes permanent.</li>
          <li>T2 has rolled back, so its changes are undone.</li>
        </ul>
        <p>
          Because T1 committed based on the value of A that T2 had read, but T2
          never committed its changes, the database might end up in an
          inconsistent state. Specifically, if T1 committed based on the
          assumption that T2 would also commit, rolling back T2 means T1's
          changes were made based on uncommitted data, which now gets undone.
        </p>
        <p></p>
        <h3>Q24.What is the importance of a trigger ?</h3>
        <p>Ans:Importance of a Trigger:</p>
        <p>
          A trigger is a special type of stored procedure in a database that
          automatically executes or fires in response to specific events, such
          as insertions, updates, or deletions on a table. Triggers are crucial
          in database management for several reasons:
        </p>
        <ol start="1">
          <li>
            Automatic Enforcement of Business Rules: Triggers can enforce
            complex business rules automatically. For example, a trigger can
            ensure that when a new employee is added, their salary adheres to
            company policies.
          </li>
          <li>
            Data Validation: Triggers can validate data before it's committed to
            the database. For example, a trigger can prevent the insertion of a
            negative value in a salary field.
          </li>
          <li>
            Auditing and Logging: Triggers can maintain logs of changes made to
            data. For example, a trigger can record details of updates made to a
            table, capturing who made the change and when.
          </li>
          <li>
            Maintaining Referential Integrity: Triggers help maintain data
            consistency and integrity. For example, a trigger can automatically
            update or delete related records in other tables when a record in
            the primary table is updated or deleted.
          </li>
          <li>
            Automating Actions: Triggers can automate tasks that need to occur
            as a result of certain events. For example, a trigger can
            automatically send a notification email when a new order is placed.
          </li>
        </ol>
        <p>Example:</p>
        <p>
          Consider an e-commerce system with a Products table and an Inventory
          table. If a product's quantity is updated, you might use a trigger to
          automatically adjust related records or notify the inventory manager.
        </p>
        <p></p>
        <h3>Q25.What is the role of commit ? Explain with examples.</h3>
        <p>
          Ans: In a database management system, the COMMIT statement is used to
          finalize a transaction. It ensures that all changes made during the
          transaction are saved permanently in the database.
        </p>
        <p>Key Functions:</p>
        <ol start="1">
          <li>
            Finalization of Changes: The COMMIT statement makes all changes made
            during a transaction permanent. Once committed, these changes cannot
            be undone.
          </li>
          <li>
            Consistency: By executing a COMMIT, the database is updated
            consistently, meaning that all operations within the transaction are
            applied together.
          </li>
          <li>
            Visibility: After committing, changes become visible to other
            transactions. This allows other users or processes to see the
            updated data.
          </li>
        </ol>
        <p>Examples:</p>
        <p>
          In a banking system, consider a transaction to transfer money between
          two accounts:
        </p>
        <ul>
          <li>Begin the transaction.</li>
          <li>Deduct an amount from Account A.</li>
          <li>Add the same amount to Account B.</li>
          <li>Execute COMMIT to finalize the transaction.</li>
        </ul>
        <p>
          If the COMMIT is executed, the changes are saved, and the transfer is
          complete. If the transaction fails or is not committed, no changes are
          made, and the database remains unchanged.
        </p>
        <p>In an online shopping system:</p>
        <ul>
          <li>Begin the transaction.</li>
          <li>Update the inventory to reflect the purchase.</li>
          <li>Record the order details.</li>
          <li>Charge the customer’s payment method.</li>
          <li>Execute COMMIT to finalize the transaction.</li>
        </ul>
        <p>
          When the COMMIT is executed, all these operations are saved, and the
          order is processed. If the COMMIT is not executed, the transaction can
          be rolled back, and no changes will be saved.
        </p>
        <p></p>
        <h3>Q26.Distinguish between Live Lock and Dead Lock</h3>
        <p>Ans:</p>
        <table>
          <tbody>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Aspect</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Live Lock</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>Dead Lock</p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Definition</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  A situation where two or more transactions continuously change
                  states in response to each other but never progress to
                  completion.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  A situation where two or more transactions are stuck, each
                  waiting for resources held by the other, causing a standstill.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Symptoms</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Transactions are active but continually changing states
                  without making progress.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Transactions are stuck and cannot proceed because they are
                  waiting for each other to release resources.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Resource Utilization</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Resources are not utilized effectively as transactions are in
                  a loop trying to avoid conflict.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Resources are held by transactions but not being utilized
                  effectively as they are waiting indefinitely.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Resolution</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Often resolved by introducing random delays or using backoff
                  strategies to break the cycle.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Typically resolved by detecting the deadlock and then aborting
                  one or more transactions to break the cycle.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Example</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Two transactions repeatedly try to acquire locks on resources
                  held by the other but back off each time, leading to
                  continuous retrying.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Transaction A holds a lock on Resource 1 and waits for
                  Resource 2 held by Transaction B, while Transaction B waits
                  for Resource 1 held by Transaction A.
                </p>
              </td>
            </tr>
            <tr>
              <td colspan="1" rowspan="1">
                <p>Impact on System</p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  May lead to decreased system performance due to constant
                  retrying and context switching.
                </p>
              </td>
              <td colspan="1" rowspan="1">
                <p>
                  Results in a complete halt of the involved transactions,
                  potentially leading to a system-wide impact if not resolved.
                </p>
              </td>
            </tr>
          </tbody>
        </table>
        <p></p>
        <h3>
          Q27Consider the following relational scheme : <br />Employee ( ename,
          street, location ) Works ( ename, cname, sal ) Company ( cname,
          location ) Managers ( ename, mgr_name ) <br />Express the following in
          SQL : <br />i) Find the name and location of residence of all
          employees who work for 'CTS'. <br />ii) Find the name, street and
          location of all employees who work for 'TCS' and earn more than Rs.
          20,000. <br />iii) Find the name of all employees who live in the same
          city as the company for which they work. <br />iv) Find the names of
          all employees who live in the same location and in the street as do
          their managers. <br />v) Assume the companies may be located in
          several cities. Find all companies name located in every location in
          which 'IBM' is located. <br />vi) Find the name of all employees who
          earn more than every employee of 'TCS' company
        </h3>
        <p>
          Ans: Here are the SQL queries for each of the requirements based on
          the given relational schema:
        </p>
        <p>Schema:</p>
        <ul>
          <li>Employee (ename, street, location)</li>
          <li>Works (ename, cname, sal)</li>
          <li>Company (cname, location)</li>
          <li>Managers (ename, mgr_name)</li>
        </ul>
        <p>SQL Queries:</p>
        <p>
          i) Find the name and location of residence of all employees who work
          for 'CTS':
        </p>
        <p>sql</p>
        <p></p>
        <p>SELECT E.ename, E.location</p>
        <p>FROM Employee E</p>
        <p>JOIN Works W ON E.ename = W.ename</p>
        <p>WHERE W.cname = 'CTS';</p>
        <p></p>
        <p>
          ii) Find the name, street, and location of all employees who work for
          'TCS' and earn more than Rs. 20,000:
        </p>
        <p>sql</p>
        <p></p>
        <p>SELECT E.ename, E.street, E.location</p>
        <p>FROM Employee E</p>
        <p>JOIN Works W ON E.ename = W.ename</p>
        <p>WHERE W.cname = 'TCS' AND W.sal > 20000;</p>
        <p></p>
        <p>
          iii) Find the name of all employees who live in the same city as the
          company for which they work:
        </p>
        <p>sql</p>
        <p></p>
        <p>SELECT E.ename</p>
        <p>FROM Employee E</p>
        <p>JOIN Works W ON E.ename = W.ename</p>
        <p>JOIN Company C ON W.cname = C.cname</p>
        <p>WHERE E.location = C.location;</p>
        <p></p>
        <p>
          iv) Find the names of all employees who live in the same location and
          in the street as do their managers:
        </p>
        <p>sql</p>
        <p></p>
        <p>SELECT E.ename</p>
        <p>FROM Employee E</p>
        <p>JOIN Managers M ON E.ename = M.ename</p>
        <p>JOIN Employee EM ON M.mgr_name = EM.ename</p>
        <p>WHERE E.location = EM.location AND E.street = EM.street;</p>
        <p></p>
        <p>
          v) Assume the companies may be located in several cities. Find all
          company names located in every location in which 'IBM' is located:
        </p>
        <p>sql</p>
        <p></p>
        <p>SELECT C1.cname</p>
        <p>FROM Company C1</p>
        <p>WHERE NOT EXISTS (</p>
        <p>SELECT 1</p>
        <p>FROM Company C2</p>
        <p>WHERE C2.cname = 'IBM' AND NOT EXISTS (</p>
        <p>SELECT 1</p>
        <p>FROM Company C3</p>
        <p>WHERE C3.location = C2.location AND C3.cname = C1.cname</p>
        <p>)</p>
        <p>);</p>
        <p></p>
        <p>
          vi) Find the name of all employees who earn more than every employee
          of 'TCS':
        </p>
        <p>sql</p>
        <p></p>
        <p>SELECT E1.ename</p>
        <p>FROM Employee E1</p>
        <p>JOIN Works W1 ON E1.ename = W1.ename</p>
        <p>WHERE W1.sal > ALL (</p>
        <p>SELECT W2.sal</p>
        <p>FROM Works W2</p>
        <p>WHERE W2.cname = 'TCS'</p>
        <p>);</p>
        <p></p>
        <p>Explanation:</p>
        <ul>
          <li>
            i) Joins Employee and Works to filter employees working for 'CTS'
            and selects their names and locations.
          </li>
          <li>
            ii) Joins Employee and Works to filter employees working for 'TCS'
            with a salary greater than 20,000.
          </li>
          <li>
            iii) Joins Employee, Works, and Company to find employees whose
            location matches the location of the company they work for.
          </li>
          <li>
            iv) Joins Employee and Managers to compare the location and street
            of employees with their managers.
          </li>
          <li>
            v) Uses a nested NOT EXISTS query to find companies located in every
            location where 'IBM' is located.
          </li>
          <li>
            vi) Uses a subquery with ALL to find employees earning more than
            every employee at 'TCS'.
          </li>
        </ul>
        <p>4o mini</p>
        <p></p>
        <h3>Q28.What is the critical section ?</h3>
        <p>
          Ans: In computing, a critical section refers to a part of a program or
          process where shared resources (such as variables, files, or devices)
          are accessed or modified. To ensure the integrity of these resources
          and prevent conflicts or corruption, the critical section must be
          executed in such a way that only one process or thread can access it
          at a time.
        </p>
        <p>Key Points:</p>
        <ol start="1">
          <li>
            Exclusive Access: The critical section must be executed by only one
            process or thread at a time to prevent simultaneous access that
            could lead to inconsistencies or data corruption.
          </li>
          <li>
            Mutual Exclusion: This principle ensures that no two processes or
            threads can be in their critical sections at the same time.
            Mechanisms like locks, semaphores, or mutexes are used to enforce
            mutual exclusion.
          </li>
          <li>
            Synchronization: Proper synchronization techniques are needed to
            manage access to the critical section. These techniques prevent race
            conditions, where the outcome depends on the unpredictable sequence
            of access to the critical section.
          </li>
        </ol>
        <p></p>
        <h3>Q29.What is schedule ?</h3>
        <p>
          Ans: In database management, a schedule refers to the sequence of
          operations (such as read and write actions) performed by multiple
          transactions. It outlines the order in which these operations are
          executed, and it is used to ensure that transactions are carried out
          in a way that maintains the database's consistency and integrity.
        </p>
        <p>Key Points:</p>
        <ol start="1">
          <li>
            Operations: A schedule includes various operations performed by
            transactions, such as reading from or writing to the database.
          </li>
          <li>
            Transaction Sequence: It represents the order in which transactions
            are executed. This can affect the final outcome of the database
            operations.
          </li>
          <li>
            Types of Schedules:<br />Serial Schedule: Transactions are executed
            sequentially, one after another, without any overlap. The results
            are the same as if the transactions were executed in a single
            sequence.<br />Concurrent Schedule: Transactions are executed
            concurrently (i.e., their operations are interleaved). It aims to
            improve performance but needs to ensure consistency through proper
            concurrency control mechanisms.
          </li>
          <li>
            Serializability: A schedule is considered serializable if its
            outcome is equivalent to some serial schedule. This means that even
            though transactions are executed concurrently, their final result is
            consistent with some serial order of execution.
          </li>
        </ol>
        <h3>Q30.What are semaphores ?</h3>
        <p>
          Ans: Semaphores are synchronization tools used in computing to manage
          access to shared resources by multiple processes or threads. They help
          ensure that resources are used safely and efficiently, especially in
          concurrent systems where multiple processes or threads might need to
          access the same resource simultaneously.
        </p>
        <p>Key Points:</p>
        <ol start="1">
          <li>
            Definition: A semaphore is a synchronization primitive that controls
            access to a common resource by multiple processes or threads. It
            helps to prevent conflicts and ensures orderly access.
          </li>
          <li>Types of Semaphores:</li>
        </ol>
        <ul>
          <li>
            Binary Semaphore: Also known as a mutex, it has only two states: 0
            and 1. It is used to ensure mutual exclusion, allowing only one
            process or thread to access a critical section at a time.
          </li>
          <li>
            Counting Semaphore: It can have any non-negative integer value and
            is used to manage access to a pool of resources. It allows multiple
            processes or threads to access the resource up to a certain limit.
          </li>
        </ul>
        <ol start="3">
          <li>Operations:</li>
        </ol>
        <ul>
          <li>
            P Operation (Wait): This operation decreases the semaphore value. If
            the value is greater than 0, the process or thread proceeds. If the
            value is 0, it waits until the value becomes positive.
          </li>
          <li>
            V Operation (Signal): This operation increases the semaphore value.
            If there are processes or threads waiting, one of them will be
            allowed to proceed.
          </li>
        </ul>
        <ol start="4">
          <li>Usage: Semaphores are used to:</li>
        </ol>
        <ul>
          <li>
            Implement mutual exclusion, ensuring only one process or thread can
            access a critical section at a time.
          </li>
          <li>
            Control access to a limited number of resources, such as a set of
            database connections.
          </li>
          <li>
            Coordinate the execution of processes or threads by signaling and
            waiting for conditions to be met.
          </li>
        </ul>
        <h3>Q31.What is two-phase locking ? Discuss it.</h3>
        <p>
          Ans: Two-Phase Locking (2PL) is a concurrency control protocol used in
          database systems to ensure that transactions are executed in a way
          that maintains consistency and avoids conflicts like deadlocks or data
          inconsistency. The main objective of 2PL is to ensure that a schedule
          is serializable, meaning it produces the same results as if
          transactions were executed one after another (serially).
        </p>
        <p>Phases of Two-Phase Locking:</p>
        <ol start="1">
          <li>Growing Phase:</li>
        </ol>
        <ul>
          <li>
            In this phase, a transaction can acquire locks (shared or exclusive)
            but cannot release any locks.
          </li>
          <li>
            The transaction continues to acquire all the locks it needs for its
            operations during this phase.
          </li>
        </ul>
        <ol start="2">
          <li>Shrinking Phase:</li>
        </ol>
        <ul>
          <li>
            In this phase, a transaction can release locks but cannot acquire
            any new locks.
          </li>
          <li>
            Once a transaction starts releasing locks, it enters the shrinking
            phase and can no longer request new locks.
          </li>
        </ul>
        <p>
          A transaction must follow these two phases strictly. The growing phase
          happens first, followed by the shrinking phase. This ensures that all
          required locks are obtained before any are released.
        </p>
        <p>How 2PL Works:</p>
        <ul>
          <li>
            When a transaction starts, it enters the growing phase and requests
            the necessary locks.
          </li>
          <li>
            Once it has all the locks it needs, it begins executing its
            operations.
          </li>
          <li>
            As the transaction progresses, it may start releasing locks, which
            marks the beginning of the shrinking phase.
          </li>
          <li>
            The transaction cannot acquire any new locks after it starts
            releasing them.
          </li>
        </ul>
        <p></p>
        <p></p>
      </div>
    </div>

    <!-- Footer starts -->
    <div id="footer"></div>
    <script src="/dynamic.js"></script>
    <script src="/script.js"></script>

    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz"
      crossorigin="anonymous"
    ></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Get all tables in the page
        const tables = document.querySelectorAll("table");

        // Loop through each table and add Bootstrap classes and custom styles
        tables.forEach((table) => {
          // Add Bootstrap classes for table styling
          table.classList.add(
            "table",
            "table-bordered",
            "table-hover",
            "table-responsive-sm"
          );

          // Check if the table has a header (thead) and style it
          const thead = table.querySelector("thead");
          if (thead) {
            thead.classList.add("thead-light");
            thead.querySelectorAll("th").forEach((th) => {
              th.style.textAlign = "center";
              th.style.verticalAlign = "middle";
              th.style.fontSize = "16px";
              th.style.padding = "10px";
            });
          }

          // Style table body rows and cells
          const tbody = table.querySelector("tbody");
          if (tbody) {
            tbody.querySelectorAll("tr").forEach((tr, index) => {
              tr.querySelectorAll("td").forEach((td) => {
                td.style.textAlign = "center";
                td.style.verticalAlign = "middle";
                td.style.fontSize = "16px";
                td.style.padding = "10px";
                td.style.border = "2px solid #dee2e6"; // Thicker border
              });
              // Alternate row background color for readability
              if (index % 2 === 1) {
                tr.style.backgroundColor = "#f9f9f9";
              }
              // Hover effect for rows
              tr.addEventListener("mouseover", () => {
                tr.style.backgroundColor = "#e9ecef";
              });
              tr.addEventListener("mouseout", () => {
                tr.style.backgroundColor =
                  index % 2 === 1 ? "#f9f9f9" : "white";
              });
            });
          }
        });
      });
    </script>
  </body>
</html>
